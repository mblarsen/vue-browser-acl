{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import Acl from 'browser-acl'\nimport { Verb, VerbObject } from 'browser-acl'\nimport { VueConstructor, VNode, DirectiveFunction } from 'vue/types'\nimport { DirectiveBinding } from 'vue/types/options'\nimport VueRouter, { Route } from 'vue-router/types'\n\nimport {\n  AclWithRouter,\n  Behaviour,\n  Options,\n  PromiseChain,\n  SetupCallback,\n  User,\n  UserGetter,\n  VueAcl,\n  VueRouterMeta,\n} from '../types'\n\nexport {\n  AclWithRouter,\n  Behaviour,\n  Options,\n  PromiseChain,\n  SetupCallback,\n  User,\n  UserGetter,\n  VueRouterMeta,\n} from '../types'\n\ninterface LooseHTMLElement extends HTMLElement {\n  disabled: boolean\n  readOnly: boolean\n}\n\nconst VueAcl: VueAcl = {\n  install(\n    Vue: VueConstructor,\n    user: User | UserGetter,\n    aclOrSetupCallback: Acl | SetupCallback | undefined = undefined,\n    options: Partial<Options> = {},\n  ): void {\n    const userAccessor: Function =\n      typeof user === 'function' ? user : () => user\n\n    /* defaults */\n    const strict = Boolean(options.strict)\n\n    const opt: Options = Object.assign(\n      {\n        acl: { strict },\n        aliases: ['role'],\n        assumeGlobal: !strict,\n        caseMode: true,\n        debug: false,\n        directive: 'can',\n        failRoute: '/',\n        helper: true,\n        strict: false,\n      },\n      options,\n    )\n\n    const findCan = findCanWithOptions(opt)\n\n    /* setup acl */\n    let acl: AclWithRouter = new Acl(opt.acl) as AclWithRouter\n    if (typeof aclOrSetupCallback === 'function') {\n      aclOrSetupCallback(acl)\n    } else if (aclOrSetupCallback instanceof Acl) {\n      acl = aclOrSetupCallback\n    }\n\n    /* router init function */\n    acl.router = function (router: VueRouter) {\n      opt.router = router\n\n      const canNavigate = (\n        verb: string,\n        verbObject: string | null,\n        ...otherArgs: any[]\n      ) => {\n        return (\n          (verbObject &&\n            acl.can(userAccessor(), verb, verbObject, ...otherArgs)) ||\n          (!verbObject && !opt.strict)\n        )\n      }\n\n      /* convert 'edit Post' to ['edit', 'Post'] */\n      const aclTuple = (value: string): [string, string | null] => {\n        const [verb, verbObject = opt.assumeGlobal ? Acl.GlobalRule : null] =\n          value.split(' ')\n        return [verb, verbObject]\n      }\n\n      /**\n       * chain all can-statements and functions as promises\n       * each can-function must return a promise (in strict\n       * mode at least). To break the chain return a none\n       * true value\n       */\n      const chainCans = (\n        metas: VueRouterMeta[],\n        to: Route,\n        from: Route,\n      ): PromiseChain => {\n        let fail: string | null = null\n        const chain: PromiseChain = metas.reduce((chain, meta) => {\n          return (\n            chain\n              .then((result: any) => {\n                if (result !== true) {\n                  return result\n                }\n\n                if (typeof meta.fail === 'string') {\n                  fail = meta.fail\n                }\n\n                const can = findCan(meta)\n\n                const nextPromise =\n                  typeof can === 'function'\n                    ? can(to, from, canNavigate)\n                    : Promise.resolve(canNavigate(...aclTuple(can)))\n\n                if (opt.strict && !(nextPromise instanceof Promise)) {\n                  throw new Error(\n                    '$route.meta.can must return a promise in strict mode',\n                  )\n                }\n\n                return nextPromise\n              })\n              // convert errors to false\n              .catch((error) => {\n                if (opt.debug) {\n                  console.error(error)\n                }\n                return false\n              })\n          )\n        }, Promise.resolve(true)) as PromiseChain\n        chain.getFail = () => fail\n        return chain\n      }\n\n      router.beforeEach((to: Route, from: Route, next: any) => {\n        const metas = to.matched\n          .filter((route) => route.meta && findCan(route.meta))\n          .map((route) => route.meta)\n\n        const chain = chainCans(metas, to, from)\n\n        chain.then((result) => {\n          if (result === true) {\n            return next()\n          }\n\n          let fail: string | Function | null = chain.getFail() || opt.failRoute\n\n          if (fail === '$from') {\n            fail = from.path\n          }\n\n          next(typeof fail === 'function' ? fail(to, from) : fail)\n        })\n      })\n    }\n\n    /* init router */\n    if (opt.router) {\n      acl.router(opt.router)\n    }\n\n    /* directive update handler */\n    const directiveHandler: DirectiveFunction = function (\n      el: HTMLElement,\n      binding: DirectiveBinding,\n      vnode: VNode,\n    ): void {\n      const behaviour: Behaviour = getBehaviour(binding.modifiers)\n\n      let verb, verbArg, verbObject, params\n      verbArg = binding.arg\n\n      if (Array.isArray(binding.value) && binding.expression?.startsWith('[')) {\n        ;[verb, verbObject, params] = binding.modifiers.global\n          ? arrayToGlobalExprTpl(binding)\n          : arrayToExprTpl(binding)\n      } else if (typeof binding.value === 'string') {\n        ;[verb, verbObject, params] = stringToExprTpl(binding, vnode, opt)\n      } else if (verbArg && typeof binding.value === 'object') {\n        verb = verbArg\n        verbObject = binding.value\n        params = []\n      } else if (\n        binding.value === undefined &&\n        !binding.modifiers.global &&\n        opt.assumeGlobal\n      ) {\n        // Fall back to global if no value is provided\n        verb = verbArg\n        verbObject = Acl.GlobalRule\n        params = []\n      }\n\n      if (opt.assumeGlobal && !verbObject) {\n        verbObject = Acl.GlobalRule\n        params = params || []\n        verb = verb || verbArg\n      }\n\n      if (!verb || !verbObject) {\n        throw new Error('Missing verb or verb object')\n      }\n\n      const aclMethod =\n        (binding.modifiers.some && 'some') ||\n        (binding.modifiers.every && 'every') ||\n        'can'\n\n      const ok = acl[aclMethod](userAccessor(), verb, verbObject, ...params)\n      const not = binding.modifiers.not\n\n      const el_ = el as LooseHTMLElement\n\n      if (!el.hasAttribute('disabled')) {\n        el_.disabled = false\n      }\n\n      if (!el.hasAttribute('readOnly')) {\n        el_.readOnly = false\n      }\n\n      if ((ok && not) || (!ok && !not)) {\n        if (behaviour === 'hide') {\n          commentNode(el, vnode)\n        } else if (behaviour === 'disable') {\n          el_.disabled = true\n        } else if (behaviour === 'readonly') {\n          el_.readOnly = true\n        }\n      }\n    }\n\n    /* set up directive for 'can' and aliases */\n    const directiveNames = [opt.directive, ...opt.aliases]\n    directiveNames.forEach((name) => Vue.directive(name, directiveHandler))\n\n    /* define helpers */\n    if (opt.helper) {\n      const helper = `$${opt.directive}`\n      /* @type AclHelper */\n      Vue.prototype[helper] = function (\n        verb: Verb,\n        verbObject: VerbObject,\n        ...args: any[]\n      ) {\n        return acl.can(userAccessor(), verb, verbObject, ...args)\n      }\n      /* @type AclHelper */\n      Vue.prototype[helper].not = function (\n        verb: Verb,\n        verbObject: VerbObject,\n        ...args: any[]\n      ) {\n        return !acl.can(userAccessor(), verb, verbObject, ...args)\n      }\n      /* @type AclHelperMany */\n      Vue.prototype[helper].every = function (\n        verb: Verb,\n        verbObjects: VerbObject[],\n        ...args: any[]\n      ) {\n        return acl.every(userAccessor(), verb, verbObjects, ...args)\n      }\n      /* @type AclHelperMany */\n      Vue.prototype[helper].some = function (\n        verb: Verb,\n        verbObjects: VerbObject[],\n        ...args: any[]\n      ) {\n        return acl.some(userAccessor(), verb, verbObjects, ...args)\n      }\n    }\n  },\n}\n\nfunction getBehaviour(modifiers: any): Behaviour {\n  if (typeof modifiers.disable !== 'undefined') {\n    return 'disable'\n  }\n  if (typeof modifiers.readonly !== 'undefined') {\n    return 'readonly'\n  }\n  return 'hide'\n}\n\n/**\n * Create comment node\n *\n * @private\n * @author https://stackoverflow.com/questions/43003976/a-custom-directive-similar-to-v-if-in-vuejs#43543814\n */\nfunction commentNode(el: HTMLElement, vnode: VNode) {\n  const comment = document.createComment(' ')\n\n  Object.defineProperty(comment, 'setAttribute', {\n    value: () => undefined,\n  })\n\n  vnode.text = ' '\n  vnode.elm = comment\n  vnode.isComment = true\n  vnode.tag = undefined\n\n  vnode.data = vnode.data || {}\n  vnode.data.directives = undefined\n\n  if (vnode.componentInstance) {\n    // @ts-ignore\n    vnode.componentInstance.$el = comment\n  }\n\n  if (el.parentNode) {\n    el.parentNode.replaceChild(comment, el)\n  }\n}\n\n/**\n * Return the first property from meta that is 'can' or one of its aliases.\n */\nconst findCanWithOptions =\n  (opt: Options) =>\n  (meta: VueRouterMeta): string | Function => {\n    return ([opt.directive, ...(opt.aliases || [])] as string[])\n      .map((key: string) => meta[key])\n      .filter(Boolean)\n      .shift()\n  }\n\n/**\n * Maps binding.value of type array to expression tuple\n */\nconst arrayToExprTpl = ({ arg, value }: DirectiveBinding) => [\n  arg || value[0],\n  arg ? value[0] : value[1],\n  arg ? value.slice(1) : value.slice(2),\n]\n\n/**\n * Maps binding.value of type array to global expression tuple\n */\nconst arrayToGlobalExprTpl = ({ arg, value }: DirectiveBinding) => [\n  arg || value[0],\n  Acl.GlobalRule,\n  arg ? value : value.slice(1),\n]\n\n/**\n * Maps binding.value of type string to expression tuple\n */\nconst stringToExprTpl = (\n  { arg, value, modifiers }: DirectiveBinding,\n  vnode: VNode,\n  opt: Options,\n) => {\n  let [verb, verbObject] = arg ? [arg, value] : value.split(' ')\n\n  if (verbObject && modifiers.global) {\n    throw new Error(\n      'You cannot provide verb object and use global modifier at the same time',\n    )\n  }\n\n  if (\n    typeof verbObject === 'string' &&\n    opt.caseMode &&\n    verbObject[0].match(/[a-z]/) &&\n    typeof vnode.context === 'object'\n  ) {\n    verbObject = vnode.context.$data[verbObject]\n  }\n\n  return [verb, verbObject, []]\n}\n\nexport default VueAcl\n"],"names":["VueAcl","install","Vue","user","aclOrSetupCallback","options","undefined","userAccessor","strict","Boolean","opt","Object","assign","acl","aliases","assumeGlobal","caseMode","debug","directive","failRoute","helper","findCan","findCanWithOptions","Acl","router","canNavigate","verb","verbObject","can","beforeEach","to","from","next","chain","metas","fail","reduce","meta","then","result","nextPromise","Promise","resolve","split","GlobalRule","Error","catch","error","console","getFail","chainCans","matched","filter","route","map","path","directiveHandler","el","binding","vnode","verbArg","params","modifiers","behaviour","disable","readonly","arg","Array","isArray","value","expression","_binding$expression","startsWith","global","arrayToGlobalExprTpl","arrayToExprTpl","stringToExprTpl","ok","some","every","not","el_","hasAttribute","disabled","readOnly","comment","document","createComment","defineProperty","text","elm","isComment","tag","data","directives","componentInstance","$el","parentNode","replaceChild","commentNode","forEach","name","prototype","verbObjects","key","shift","slice","match","context","$data"],"mappings":"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"}